# d1={5:[(7),(3)],
#    7:[(5),(4),(3)],
#    4:[(7),(8),(2)],
#    3:[(5),(7),(8)],
#    8:[(3),(4),(2)],
#    2:[(4),(8)]}

# d={1:[(2,3),(4,2)],
#    2:[(1,3),(3,4)],
#    3:[(2,4),(7,8)],
#    4:[(1,2),(8,1),(5,5)],
#    5:[(4,5),(6,6),(9,7)],
#    6:[(5,6)],
#    7:[(3,8)],
#    8:[(4,1)],
#    9:[(5,7)]
# }
# def bfs_spanning_tree(x):
#     v=[]
#     q=[x]
#     while q:
#         for i,j in d[q[0]]:
#             if i not in q and i not in v:
#                 q.append(i)
#         v.append(q.pop(0))
#         print(v[-1],end=" ")
d1={1:[(2,3),(4,2)],
   2:[(1,3),(3,4)],
   3:[(2,4),(7,8)],
   4:[(1,2),(8,1),(5,5)],
   5:[(4,5),(6,6),(9,7)],
   6:[(5,6)],
   7:[(3,8)],
   8:[(4,1)],
   9:[(5,7)]
}
def dj(x):
    d={1:9999,2:9999,3:9999,4:9999,5:9999,6:9999,7:9999,8:9999,9:9999}
    d[x]=0
    v=[]
    q=[x]
    while q:
        m=999
        for _ in q:
            if d[_]<m:
                m=d[_]
                x=_
        for i,j in d1[x]:
            # v.append(x)
            # q.append(i)
            if i not in v:
                q.append(i)
                if d[i]>j+d[x]:
                    d[i]=j+d[x]
        v.append(q[0])
        q.remove(x)        
    print(d)

dj(5)
